# 0802

# 記録さぼり + 保存ミスで消えた0729以降の記録を復讐しながら簡易的に再掲載

# ARC031B 埋め立て　2回目

解答遷移  AC

baseまで 17:42  デバック 01:20

備考

➀ 「島がひうとつながりである」か否かの判定を、探索した陸を消して最後に陸が残っているか否かで判定することが可能。

解答例 : https://ebisuke33.hatenablog.com/entry/antbook-arc031b


# 233A 10 yen Stamp

備考

➀ XをYで割った解の小数切り上げ

(X+Y-1)//Y

イメージ的にはX//Yをbaseに、XがYで割り切れる時以外は、+Yの部分が効いて切り上げられる。

割り切れる場合は-1の部分が効いて、切り上げが起こらないようになる。

➁ Xが既にYを上回っている場合

この場合に((X+Y)+10-1)//10 をすると負値になるので条件処理するか、max(0,)とする



# アルゴ式 グラフアルゴリズム

# 1-2 フォロー

備考 

なし



# 1-3 人気者の友達 2回目

解答遷移 AC

baseまで 08:08  デバック&提出 04:52  計 13:00

備考

➀ * 復習 mapはイテレータ

A=[1,2]のとき

a,b=A , a,b=map(int,A)  と要素にアクセスすれば違いはないがa=Aとすればリストが返ることと違ってイテレータは返らない

➁ 復習時と初見時の方針の違い　（情報の分割)

復習時

ABを入力から得た友達リストとしてA[n]に[nの友達の数(len(AB[n]) , -n , AB[n]]を格納しソートすることで友達の数が多い順でかつindex番号が小さい順に並べ替えることができる。そして最後にsorted(A)[0][-1]をソートすればよい。

初見時

入力からで友達リストを作成すると同時に、友達の多さリストを作成。多さリストの最大値のindex番号こそ、友達が最も多くindex番号が小さいもののindex番号になるので友達リストからそのものの友達を求めればよい。


確実に初見時のほうがスマート。ループ処理1回で解決している。全ての情報をはらんだリストを再構築する復習時のほうが情報をコンパクトにまとめられる点は優れているが、友達の多さは多い順、index番号は若い順で異なるためindex番号を-1倍処理する必要があることや、そもそもどんな情報を格納すべきか難しい部分があるため自分では実装に時間がかかってしまう。



# 1-4 友達の友達 2回目

解答遷移 AC

備考

➀ リストの要素検索

a (not) in A としてAの要素にaがあるかの処理は　O(n) である。よって制約次第で使えなくなる可能性が高い。setであればO(1)らしいのでこちらを使用するようにする。

![image](https://user-images.githubusercontent.com/109026838/182563153-57676d80-383b-4188-a3d3-7d2f9bf4e5ef.png)

*  2-2後 追記

リストをセットに変換して要素検索するのと、セットを直接検索するのとでは計算時間が異なる(0801_0806 tttt.py参照)

そのため検索したい場合にはあらかじめ空のset()を作っておき、こちらにも値を格納する処理がTLEしないためにより良い。




# 2-1 箱の中の箱　2回目

解答遷移 AC

問題把握 01:43  発想 01:42  base & デバック 05:05  計 08:31


備考

➀ 根からの探索

特定の頂点(箱)Xの深さを調べるなら、根からでたらめにたどっていくよりも直接その頂点から根に向かった方が効率的

➁ dp的解放

「ある頂点(箱)における根からの深さは、その親の頂点の深さ+1 」 である性質を利用すればすべての頂点の深さを求めることができる。


# 2-2 行きがけ順　2回目

解答遷移 RE(TLE)  AC 

問題把握 00:32 　発想 00:01  base 17:13  計 17:46

備考

なし


# 0804

# 2-3  頂点の深さ　2回目

備考

➀ 探索の方向

今回は全ての頂点の根からの深さを求めることになるので、特定の頂点から出発するほうが良いと思われる。この場合自分の子の深さを+1して、その子を根とした部分木に対して同じ処理をすればよい。

逆に頂点からスタートするとその親の深さが分かっていな可能性があり、その時用の別の処理が必要になり煩雑化する。


# 2-4 木の高さ　2回目

解答遷移 AC

問題把握 00:27  発想 00:00  base 04:28  デバック 00:53  計 05:49

備考

2-3と同じ処理が9割9分を占めるので復習必要ない



# 2-5 子孫の個数   諦めてみ正解状態(解説等見てない)

解答遷移　AC

問題把握 & 発想 13:01  base 11:23  デバック&提出  14:53  計 39:18

備考

➀　行きがけ、帰りがけ

木構造において部分木を探索する前に処理を施す場合を行きがけ、部分木の処理が完了してから処理を施す場合を帰りがけという。

頂点の根からの深さはその親の深さがわかっていれば+1することで求められるので、ある頂点の深さは根方向から順に、つまり行きがけ順に求められる。逆にある頂点の子孫の数などを求めたい場合などは、子孫に対する処理が完了していないとわからないので葉方向、つまり帰りがけ順に求めることができる。

codeでは dfsを再帰する前に処理するか後に処理するかだけの違いである。




# 230A AtCoder Quiz 3

備考

➀ 初見で一瞬でできた記憶があるため再回答せず。特に記述もなし




# 229A First Grid

備考

➀ 条件を満たすパターンが限られているので、ループを回すよりも直接入力が条件を満たすか判定するほうが楽なパターン



# 228A  Mnay Oranges　2回目

解答遷移 AC

問題把握 & 発想 00:00  base 05:08  デバッグ&提出 00:31  計  10:51

備考

➀　探索対象は何？

重さがWという条件から、みかんの重さを動かし合計がWになるような状態を見つけたくなる。例えばW=1500でみかんの最小値が400 最大値が800の場合、800のみかんを選び残りは700で範囲内にあるので最小値は2個という方針を取りたくなる。しかしW=1700の場合では、800のみかんを２つ選んでも残りの重さを補える重さのみかんを選ぶことはできない。そのため今度は800のみかんを1つ選び次に799のみかんを、、、とはてしない処理を行うことになる。

このように自然に思い付いた方針がだめなら視点を変えてみよう。例えば動かす対象を重さからみかんの個数に変えることでこの問題は解決できる。A * i<= W <= B * i ・・ ➀　が成り立つなら、重さの組み合わせこそわからないが、i個選べばちょうどWとなるようにみかんを選ぶことは判別できる。これをW < A * j になるまで繰り返し一番最初に➀を満たしたiが最小値となり、一番最後に➀を満たしたiが最大値となる。



# ☆ 257C Robot Takahashi  2回目

解答遷移 TLE 諦め

備考

➀　listのsliceの計算量

スライスはcopyしてるらしく、要素の長さkに依存するO(k)になるらしい。そのため大人と子供の境界を探索したうえで、大人リストと子供リストを作ると計算量は O((10^5)^2)になりTLEしたと考えられる。


➁ sliceを使わない境界前方の0の数と1の数の数え上げ

1,境界の移動で生じる±を逐次計算

2,累積和

3,2部探索


③ Wが重複している場合の境界線の処理(工夫ver)
  
10の順では、|10 の境界線の位置の状態で一致数がXだった場合 1|0 ではX-1となり、10|でXに戻る。一方、01の順では 0|1でX+1となり、01|でXに戻る。

つまり01野場合では重複時に存在しえない境界線が一致数の最大値を不当に更新するが10野場合には更新されずに済むので、Wをの昇順をもとにsortしたうえで、10の順(降順)にSをsortしさえすれば重複を考慮しない実装が可能になる


④ 重複を考慮した逐次処理

境界の左側に含まれる0の数と1の数を境界を移動させるごとに数え上げその和の最大値を求める処理、境界の移動による正解判定数の現在値と最大値の比較。どちらの方針であっても体重重複の有無に関わらず、境界の左側に移動した値が0か1かで値を変化させる処理を行う。重複がある際に特別になることはは最大値の更新のみである。つまり重複がある場合を条件処理して特別な処理を行う必要はなく、通常の処理を行った後、更新を行う前に重複があるかを判定して、あるならcontinueで判定処理を回避するだけ、ただそれだけである。



# 0806

# 236C Route Map
 
解答遷移 AC

問題把握 02:41  発想 01:51  base 05:04  デバック&提出 00:26  計 10:04

備考

➀ set検索がO(1)であることを利用すればよいだけ

➁　それ以外の方針

1, n番目の駅は止まる駅か否か判定　→ 止まるなら止まる駅リストのindex番号を後ろにずらして次の止まる駅を検索可能にする

2, 止まる駅リストの駅に止まったらそれをリストから削除して、同じindex番号で判定し続ける。

→ TLEしないようにpop(-1)するしかないので逆順処理。



# 256C Filling 3x3 array

解答遷移 WA* 5 AC

問題把握 & 発想 03:22   base 05:39  提出 06:16  計 15:17 + 5* 05:00


備考

➀  上4マスが定まれば他のマスが一意に決まることを利用して導出。それら全てが>0以上であることに加えて間接的に求めた値で計算した最後のマス計算時に使用していない条件を満たせばカウンターを+1する処理をするだけである。

初見時の自由な発想はすばらしいが、3回ループそれぞれでproduct演算する計算量が不安。条件処理で計算量を落す方が賢い。



# 228A On and Off 

備考

➀　初見でそこまで苦労せず解けた記憶があるので解きなおしなし


kswap

13:31 14:34 03:29

計算量で方針を塾講。コード書いてるうちにどんどん良い案がうまれてきた。











