# 0802

# 記録さぼり + 保存ミスで消えた0729以降の記録を復讐しながら簡易的に再掲載

# ARC031B 埋め立て　2回目

解答遷移  AC

baseまで 17:42  デバック 01:20

備考

➀ 「島がひうとつながりである」か否かの判定を、探索した陸を消して最後に陸が残っているか否かで判定することが可能。

解答例 : https://ebisuke33.hatenablog.com/entry/antbook-arc031b


# 233A 10 yen Stamp

備考

➀ XをYで割った解の小数切り上げ

(X+Y-1)//Y

イメージ的にはX//Yをbaseに、XがYで割り切れる時以外は、+Yの部分が効いて切り上げられる。

割り切れる場合は-1の部分が効いて、切り上げが起こらないようになる。

➁ Xが既にYを上回っている場合

この場合に((X+Y)+10-1)//10 をすると負値になるので条件処理するか、max(0,)とする



# アルゴ式 グラフアルゴリズム

# 1-2 フォロー

備考 

なし




# 1-3 人気者の友達 2回目

解答遷移 AC

baseまで 08:08  デバック&提出 04:52  計 13:00

備考

➀ * 復習 mapはイテレータ

A=[1,2]のとき

a,b=A , a,b=map(int,A)  と要素にアクセスすれば違いはないがa=Aとすればリストが返ることと違ってイテレータは返らない

➁ 復習時と初見時の方針の違い　（情報の分割)

復習時

ABを入力から得た友達リストとしてA[n]に[nの友達の数(len(AB[n]) , -n , AB[n]]を格納しソートすることで友達の数が多い順でかつindex番号が小さい順に並べ替えることができる。そして最後にsorted(A)[0][-1]をソートすればよい。

初見時

入力からで友達リストを作成すると同時に、友達の多さリストを作成。多さリストの最大値のindex番号こそ、友達が最も多くindex番号が小さいもののindex番号になるので友達リストからそのものの友達を求めればよい。


確実に初見時のほうがスマート。ループ処理1回で解決している。全ての情報をはらんだリストを再構築する復習時のほうが情報をコンパクトにまとめられる点は優れているが、友達の多さは多い順、index番号は若い順で異なるためindex番号を-1倍処理する必要があることや、そもそもどんな情報を格納すべきか難しい部分があるため自分では実装に時間がかかってしまう。



# 1-4 友達の友達 2回目

解答遷移 AC

備考

➀ リストの要素検索

a (not) in A としてAの要素にaがあるかの処理は　O(n) である。よって制約次第で使えなくなる可能性が高い。setであればO(1)らしいのでこちらを使用するようにする。

![image](https://user-images.githubusercontent.com/109026838/182563153-57676d80-383b-4188-a3d3-7d2f9bf4e5ef.png)

*  2-2後 追記

リストをセットに変換して要素検索するのと、セットを直接検索するのとでは計算時間が異なる(0801_0806 tttt.py参照)

そのため検索したい場合にはあらかじめ空のset()を作っておき、こちらにも値を格納する処理がTLEしないためにより良い。




# 2-1 箱の中の箱　2回目

解答遷移 AC

問題把握 01:43  発想 01:42  base & デバック 05:05  計 08:31


備考

➀ 根からの探索

特定の頂点(箱)Xの深さを調べるなら、根からでたらめにたどっていくよりも直接その頂点から根に向かった方が効率的

➁ dp的解放

「ある頂点(箱)における根からの深さは、その親の頂点の深さ+1 」 である性質を利用すればすべての頂点の深さを求めることができる。


# 2-2 行きがけ順　2回目

解答遷移 RE(TLE)  AC 

問題把握 00:32 　発想 00:01  base 17:13  計 17:46

備考

なし


# 0804

# 2-3  頂点の深さ　2回目

備考

➀ 探索の方向

今回は全ての頂点の根からの深さを求めることになるので、特定の頂点から出発するほうが良いと思われる。この場合自分の子の深さを+1して、その子を根とした部分木に対して同じ処理をすればよい。

逆に頂点からスタートするとその親の深さが分かっていな可能性があり、その時用の別の処理が必要になり煩雑化する。


# 2-4 木の高さ　2回目

解答遷移 AC

問題把握 00:27  発想 00:00  base 04:28  デバック 00:53  計 05:49

備考

2-3と同じ処理が9割9分を占めるので復習必要ない



# 2-5 子孫の個数   諦めてみ正解状態(解説等見てない)

解答遷移　AC

問題把握 & 発想 13:01  base 11:23  デバック&提出  14:53  計 39:18

備考

➀　行きがけ、帰りがけ

木構造において部分木を探索する前に処理を施す場合を行きがけ、部分木の処理が完了してから処理を施す場合を帰りがけという。

頂点の根からの深さはその親の深さがわかっていれば+1することで求められるので、ある頂点の深さは根方向から順に、つまり行きがけ順に求められる。逆にある頂点の子孫の数などを求めたい場合などは、子孫に対する処理が完了していないとわからないので葉方向、つまり帰りがけ順に求めることができる。

codeでは dfsを再帰する前に処理するか後に処理するかだけの違いである。




# 230A AtCoder Quiz 3

備考

➀ 初見で一瞬でできた記憶があるため再回答せず。特に記述もなし




# 229A First Grid

備考

➀ 条件を満たすパターンが限られているので、ループを回すよりも直接入力が条件を満たすか判定するほうが楽なパターン



# 195B  Mnay Oranges　2回目

解答遷移 AC

問題把握 & 発想 00:00  base 05:08  デバッグ&提出 00:31  計  10:51

備考

➀　探索対象は何？

重さがWという条件から、みかんの重さを動かし合計がWになるような状態を見つけたくなる。例えばW=1500でみかんの最小値が400 最大値が800の場合、800のみかんを選び残りは700で範囲内にあるので最小値は2個という方針を取りたくなる。しかしW=1700の場合では、800のみかんを２つ選んでも残りの重さを補える重さのみかんを選ぶことはできない。そのため今度は800のみかんを1つ選び次に799のみかんを、、、とはてしない処理を行うことになる。

このように自然に思い付いた方針がだめなら視点を変えてみよう。例えば動かす対象を重さからみかんの個数に変えることでこの問題は解決できる。A * i<= W <= B * i ・・ ➀　が成り立つなら、重さの組み合わせこそわからないが、i個選べばちょうどWとなるようにみかんを選ぶことは判別できる。これをW < A * j になるまで繰り返し一番最初に➀を満たしたiが最小値となり、一番最後に➀を満たしたiが最大値となる。



# ☆ 257C Robot Takahashi  2回目

解答遷移 TLE 諦め

備考

➀　listのsliceの計算量

スライスはcopyしてるらしく、要素の長さkに依存するO(k)になるらしい。そのため大人と子供の境界を探索したうえで、大人リストと子供リストを作ると計算量は O((10^5)^2)になりTLEしたと考えられる。


➁ sliceを使わない境界前方の0の数と1の数の数え上げ

1,境界の移動で生じる±を逐次計算

2,累積和

3,2部探索


③ Wが重複している場合の境界線の処理(工夫ver)
  
10の順では、|10 の境界線の位置の状態で一致数がXだった場合 1|0 ではX-1となり、10|でXに戻る。一方、01の順では 0|1でX+1となり、01|でXに戻る。

つまり01野場合では重複時に存在しえない境界線が一致数の最大値を不当に更新するが10野場合には更新されずに済むので、Wをの昇順をもとにsortしたうえで、10の順(降順)にSをsortしさえすれば重複を考慮しない実装が可能になる


④ 重複を考慮した逐次処理

境界の左側に含まれる0の数と1の数を境界を移動させるごとに数え上げその和の最大値を求める処理、境界の移動による正解判定数の現在値と最大値の比較。どちらの方針であっても体重重複の有無に関わらず、境界の左側に移動した値が0か1かで値を変化させる処理を行う。重複がある際に特別になることはは最大値の更新のみである。つまり重複がある場合を条件処理して特別な処理を行う必要はなく、通常の処理を行った後、更新を行う前に重複があるかを判定して、あるならcontinueで判定処理を回避するだけ、ただそれだけである。



# 0806

# 236C Route Map
 
解答遷移 AC

問題把握 02:41  発想 01:51  base 05:04  デバック&提出 00:26  計 10:04

備考

➀ set検索がO(1)であることを利用すればよいだけ

➁　それ以外の方針

1, n番目の駅は止まる駅か否か判定　→ 止まるなら止まる駅リストのindex番号を後ろにずらして次の止まる駅を検索可能にする

2, 止まる駅リストの駅に止まったらそれをリストから削除して、同じindex番号で判定し続ける。

→ TLEしないようにpop(-1)するしかないので逆順処理。



# 256C Filling 3x3 array　2回目

解答遷移 WA* 5 AC

問題把握 & 発想 03:22   base 05:39  提出 06:16  計 15:17 + 5* 05:00


備考

➀  上4マスが定まれば他のマスが一意に決まることを利用して導出。それら全てが>0以上であることに加えて間接的に求めた値で計算した最後のマス計算時に使用していない条件を満たせばカウンターを+1する処理をするだけである。

初見時の自由な発想はすばらしいが、3回ループそれぞれでproduct演算する計算量が不安。条件処理で計算量を落す方が賢い。



# 228A On and Off 

備考

➀　初見でそこまで苦労せず解けた記憶があるので解きなおしなし


# 254C kswap  2回目

解答遷移  AC

問題把握&発想 13:31    base 14:34     デバック&提出 03:29  


備考

➀ 解答状況

1, sortedの各要素を入れ替えて元のリストに戻せるか　→  計算量をクリアする方針を熟考  →  移動可能なリストを作成し、そこにsortedの要素があればYesな処理を行うことにした(この時点ではどの様なコードにするか割と曖昧なまま走った)

2, コードを作成していく都度、よりよい発想が出てくるようになった。移動可能範囲は余りで分類できるし、重複もcollection.Counterで処理できることが明確化して完成


➁ 入れ替え可能範囲限定でsortedして、それが元のリストのsortedだったらYES

初見時の解法。K * N//K * N//K で計算量危なそうだなと思ったが、こっちの方が速くて？

 

# 0807

# 227A  Last Card 

備考

➀ 元のindex番号との連携

余りで分類したい + 配った枚数-1個番号を進めるため ( (A-1) + (K-1) ) % Nによってindex番号0 始まりのリストにおいて最後にカードが配られた人間が分かる。これをもとのリストのindex番号に戻すために +1 すると完成


# 198B Palindrome with leading zeros 2回目

解答遷移 AC

問題把握&発想 02:54   base 02:17  デバック&提出  05:27  計 10:39

備考

➀　桁数がmaxでも10なので絶対TLEは起きないだろうが、0の挿入位置が最後のほうが楽なので逆順のリストの末尾に0を加えていき、これを逆順したリストと同じになれば回文と判定する処理にした。なお0を加える回数はめんどくさいのでNの長さによらず10回とした。

➁ リスト == リスト　

全ての要素が同じならTrueになる。オブジェクトが否かは関係ない。もしこの問題で異常が発生したならそれはおそらくリストの要素とappendで加えた0の型が異なるというだけであると思われる。



# 251C Poem Online Judge 2回目

解答遷移 AC

問題把握 & 発想 03:00  base 02:43 デバック & 提出 02:52  計08:36

備考

なし




# 252C  Slot Strategy  2回目    済

解答遷移 WA TLE TLE RE AC

問題把握 04:33  発想 02:29  base 04:17  デバック&提出 1:07:17  計 1:18:37 + 20:00


備考

➀ whileループのカウンター処理忘れ

カウンター自体は作成できるが、カウンターを更新する処理を行うのを忘れてしまうことが多い。必ずつける

➁ 0-9のどれを揃えるかで全探索、同じ数字が同じ列になければ一番最後の列秒でそろえることが可能。もし同じ列にあれば、繰り返す回数は頻度の最大値、最後の位置はその列である、と考えていたのだが頻度の最大値が複数存在する場合に最後の位置はその中で最も後ろの列になる。数字の列の場所はcollections.Counterで管理し、most_commonで最頻値にアクセスする。実装にてまどったが、最頻値が重複する場合の処理は素直にmost_commonを前から順にアクセスして後ろの出現回数と同じなら列の番号を比較する処理を実行した。


③ 初見案

0-9のどれを揃えるか全探索する場合、各列ごとにいくつあるか知りたくなる　→ 各列の0-9ごとの頻度を格納したカウンターを作りたい　→ しかしcollection.Counterは存在しない値が格納されないので列ごとに一気に取り出すのは適さない。そこでリストcolumn_countを作成し、0次元方向に各列の情報を、一元方向に0-9のその列における頻度を格納した。それをzip処理することである数字の列ごとの頻度をとりだすことが可能になる。あとはその最大値-1を繰り返し回数、最大値のindexを止まる場所として取り出しある数字を揃える最小時間を求めることができるようになる。



# 226A Round decimals  2回目  済

解答遷移 AC

計 05:07


備考

➀ math.floor math.ceil

これらは小数の切り捨て、切り上げである。

➁ round(X,n) + 0.0000000000000002

偶数丸めの四捨五入。n桁目(小数第一位を0として、小数点方向を負で進み、末端方向を+で進む)が0-4なら切り捨て、6-9なら切り上げる。

しかし通常の四捨五入と異なり、5のときに結果を偶数に丸めこむ。なぜか+0.000005のように捨てられるくらい適当な数を足すことで、偶数の回避回避や深い小数点の四捨五入もできるようになるので必ず付け加えよう。




# 0808

# 249C Just K　2回目

解答遷移 WA AC　

問題把握 & 発想 07:59  base-提出 07:31  提出 15:31 + 05:00

備考

➀ N <= 15 と適切な数を選ぶ処理の必要性からbit探索をかんがえた。対象の文字列を全て一つのリストに格納してcounterでカウント

➁ * 復習 bit全探索

for i in range(2^N) for j in range(N) とするか、どれを選ぶかのbool値リストで for i  proudt((0,1),repeat=N) for j in range(N)とする

③ Counterへの要素の追加

1, 予めすべての要素を格納したリスト X を作成してCounter(X)

2, 空のCounter Z を用意し、uppdateで追加 Z.uppdate(S[j]) 

![image](https://user-images.githubusercontent.com/109026838/183347963-8fe5e95d-8594-479d-a399-c7c18f4bc0fa.png)

辞書型のupdateに似ているが、あちらは(key,value)のセットで追加するのに対し、こちらはkeyのみを要素にしたiterableを要求する。valueは出現回数から自動で出力される。

3 , 空のCounter Z を用意し、素直にZ[key]+=1

処理時間は 1 < 2 <<3 である。要素数の数だけforループを回す必要のある3が遅いのは当然だが、updateも早くないのでまとめてCOunterに格納しよう



# 246C Coupon 2回目

解答遷移 AC

問題把握 05:37  base 08:09  デバック&提出 01:03　計 14:49

備考

➀ クーポンを使う枚数で全探索すると制約に引っ掛かりそうだと感じた。するとそもそも値段//Xがクーポンを有効に使える枚数だし、値段%Xが残った値段であることに気づいたのでこれを利用した。


➁ 再起関数の挙動

再帰関数の処理の途中でreturnしても、最後の処理の返り値に置き換えられてしまう。そのためなにか保存したい場合は変数やリストを生成して保存するのがよいだろう。




# 242C 1111gal password 2回目

解答遷移 AC

問題把握 04:48  base 04:59  デバック 08:33  計 18:21

備考

➀ 巨大数は扱うのに時間が係るので随時余りを格納すること

➁ ループ数的にも問題なさそうだがなぜかpythonではTLEになるので、腹立たしいがpypyで出した。



# 055B Training Camp

備考

➀ 242Cと同様、余りを利用すること。再解答はしていない




# 238C digitnum

解答遷移　Ac

問題把握 05:38  base-提出 11:05  計 16:43

備考

➀ Nが一桁の時だけ例外処理したが、10^0=1 10^1=10と同一に扱えるのでそんな必要はなかった。




# 241C Connect6  2回目　　済

解答遷移 AC

問題把握 06:21  base-提出 28:09  計 34:31

備考

➀ 解答思考

コード作成前

マスを探索するからdfs? でも白マスの塗りつぶしを探索すると1000C2通りの塗りつぶし探索が加わるのでこれは無理そう。

探索中に白マスの数カウントして3以上になったら処理を行わなくすればいいか

コード作成中

探索は一方向しか進まないから再起関数使わずにforループで良いと気づいた。白マスの数とマスの範囲で条件処理して黒マスが連続して6つ並べばflagをTrueに変え、それを判断材料にansを出力する処理を実装した。


➁ 移動方向

コード作成時は気が付かなかったが、探索する移動方向は8方向でなくてよい。例えば東方向(1,0)を探索するなら、西方向(-1,0)はいらない。なぜなら西方向は既に東方向探索で検出されているからである。この考えで探索方向は8から4に落とすことが可能。


③ 別解

6つのマスをとりだして、黒が4マス以上あればYes判定

白を数えないで済む点がすぐれているが、例えば以下のような例で正しくNoを出力する処理を実装する必要がある。

![image](https://user-images.githubusercontent.com/109026838/183443233-0291d24c-debb-4849-9036-f249b833d7c7.png)


④ 別解2

これまでの解法は 方向 × マス数 × 連続マス数 の24 × N^2 の計算量であるがこれは連続マス数が6であるがゆえに許される。もし連続マス数が膨大になればTLEしてしまう。この状況でも処理可能な方針のひとつに、累積和の考えでマスの数を数えるというものが考えられる。

進行方向ごとに黒マスの数を累積していった値を格納し、始点を探索して終点との価の差に注目する方法である。注意する点としては、始点が黒マスか白マスかで連続を成立させる差の値が異なることがある。


# 以上再解答終わり

=======================================================================================================

# 以下再び編集データ消滅

# 8/9 

# 247C 1 2 3 1 2 3

解答遷移 AC

備考

➀ リストの結合は新たなリストを作成する



# 245C Choose Elements　　　済

解答遷移 WA WA AC

備考

➀ 探索方向に注意

普段は同じ行の要素を全て探索し終えた後、いつ下の行に探索を映る処理を行っているが、前の列の値を参照するdpをしたいのであれば、同じ列のすべての要素の探索を終えずに次の列に移ってはいけない。よって普段とは異なる探索をする点に気を付けたい。



# 243C Collision2

解答遷移 AC

備考

➀ 思考

y軸の値で分類して、2点が条件を満たすかという処理は絶対にTLEするので不可能。

[y軸の値, x軸の値,進行方向]を格納したリストを作成しsortして、前から順に探索しx軸の値が同じ値なら進行方向で判定する処理ならば十分高速だと考え作成




# ☆ 233C Product   済


解答遷移 方針がわからず諦め

備考

➀　条件の見方と絞り込み

１つの袋に入っているボールの数がそれぞれ10^5以下ではない。すべての総和が10^5以下である。よって全探索可能。

また、1つの袋には少なくとも2つボールが入っているので、2^10 * 2^6 < 10^5 < 2^17 より最大でも袋は16個しかないのがわかる。

➁ 再起関数

dfsで扱っていた再帰関数とは言ってしまえば何重ものforループ処理である。この問題のように2つ以上の袋のボールの組み合わせを全探索したいときに有効である。


なお関数内でのみ扱う変数を引数にすればその変数の状態を保存しながら次の関数を呼び出すことができる





# 北海道旅行により少し飛ぶ


# 08/19

# ☆ 225C_Calendar Validator　　

解答遷移 WA WA 諦め

問題把握 05:21  27分で降参


備考

➀ WA の理由

Bの全要素をB[0][0]で引いたBを作成、Bの要素すべてが行index * 7 + 列index になっているかを判定する処理で十分だと思っていたが、例えば 7 8 9 と一行に並ぶことを許してしまう点でこの処理では不十分であった。

よって、B[0][0]とMの関係に制限を設ける必要がある。具体的には、B[0][0]-1 (余りを0始まりにするための-1調整) とMの和が7より大きければ、例のような同じ行に存在し得ない要素が存在している状況であると判断するような処理をはじめに追加した。これによってACすることができるようになった。



➁ なぜコーナーケースを発見し損ねたか？

メインの処理を精査するとき、処理の内容など考慮しないで主観のみで適切なBを与えて検討を行った。これがよくない。例えば、B[0][0]を引く処理によって要素の情報が抜け落ちてしまうところに注目すれば例のような状況を考慮し損ねていることに気づけたかもしれない。処理を中心にした検討を心掛けたい。



③ u2dayoの解説が意味不明。問題が変わった？


# ☆ 223C Doukasen　　済
 
解答遷移　TLE AC　

計 1:31:02 + 05:00


備考

➀ 方針

何本目の導火線でぶつかるのかを導火線を全探索して求め、その導火線でぶつかる点をXとした方程式をたてればよいと判断。

ぶつかる導火線は、左からその導火線を燃やし尽す時間の合計と、右からその導火線を燃やし尽くすまでの時間の合計の差が初めて正になるものと解釈した。したがって、左からの導火線を燃やし尽す時間の累積和と右からの累積和を作成しそれを前から順に探索して条件を満たすときに方程式を解く処理を実装した。

➁　TLE

逆順の累積和を求める際にループ内でソートしてしまったためにTLEしてしまった。メインの処理の速度が高速なことしか確認しなかったために生じた。

③　模範解答

ぶつかるまでの時間は、導火線全体を燃やし尽す時間の半分なことに注目する。

導線を全探索して、その導線までのすべてを燃やし尽す時間とぶつかる時間を比較。ぶつかる時間のほうが大きければその導線の長さを累積し、そうでなければその手前の導線まで燃やし尽す時間とぶつかる時間の残り時間分で燃える長さを累積して終了する処理を行うことで解答可能


④ なぜくそ時間がかかったのか

222C 217B 実装終わりに記述。旅行で間が空いたことで集中力が低下していること、メガネがなく目が疲労している状態であることも少しは影響しているだろうが、diffが茶に近いと解答時間が急増する事実は実力がその程度であることを表していると思われる。さらに222Cが単純な変数のケアレスミスであることと違ってこの問題では純粋に実装にてこずった。もしかすると方程式の実装が苦手なのかもしれない。




# 222C Swiss-System Tournament

解答遷移 WA AC

計 1:02:58 + 05:00

備考

➀ WAのデバック

WAの数的にコーナーケースではなく処理自体に誤りがあるのだと思ったが、いくら考えても間違っているとは思えなかった。仕方ないのでとりあえずメイン処理のじゃんけんする2人のindex番号を取得する処理や、battle関数を簡潔化して解決しないかなと試すとACして余計に困惑した。これらを比較するとbattle関数内で扱う変数が誤っているだけだった。このようなケースは文字検索で誤りを確認できるため次回から活用したい。


➁ 二重リストsort

得点が同じならindex番号の若い順に並べるような処理は二重リスト[得点,-index番号] を降順にsortすることで実現していた。しかし[-得点,index]を昇順sortすることでも実現可能である。


* 補足 x^y

xが奇数の場合x-yを返し、偶数ならx+yを返す？

今回battle関数で誤ってi-1とするところをi^1としてしまったが、iが奇数のために偶然正しい処理ができたのだろうか。^の機能を調べてもよくわからなかった


# 217C Inverse of Permutation 

解答遷移 AC

問題把握 発想  03:30  base&デバック提出 03:52  計 07:22


備考

なし



# 0820

# 234C Happy New Year!　　済

問題把握 & 発想 07:52  base - 諦め 27:09  計 35:02

備考

➀ 思考

n桁の2,0からなる正整数が2^(n-1)個存在することに注目。nを0から始めてKから2^nを引いていきこれをremとして、初めてremが2^nを下回るところまで繰り返す処理を行う。その後(0,2)からn個取り出す処理をitertools.productで行いrem-1番目のものを"2"に足したものを出力する処理で良いなと思った。

しかし10^18であるKに対してこの処理を行う場合 nが60近いになるためbit演算の処理できる範囲を超えてしまっているためにTLEとなる。その後別案が浮かばなかっため降参した


➁模範解答

求めるべき数は2進数の数値においてK番目に小さい数の1の部分を2に変換したものと解釈できる。

bin(K)[2:] or f"{K:b}"で求めるべき2進数を文字列で出力し、replace("1","2")で文字列内の1を2に変換するか、int型に変換して2倍するかすればよい。




* 復習

mapはイテレータ。取り出す場合はリスト化が必用。


* 補足 itertools.product(X,repeat=0)

range(0)などとは異なり、空の返り値を返す。この仕様によって、K=1の処理を偶然適切に行えた




# 228C Final Day

解答遷移 AC

問題把握 発想 03:31  base 04:45  デバック&提出 01:39  計 09:56

備考

なし





# 235C The Kth Time Query 

解答遷移 AC

問題把握 02:05 発想 01:36  base 07:45  デバック&提出 01:55  計 13:22

備考

➀ collections.defaultdict(関数)

Aに出現する数をキーとして、それらすべての出現場所を格納したリストをvalueにした辞書を作成すれば、O(1)の処理で済むが、collections.Counterとは異なり辞書は存在しないキーにアクセスできないため、条件分岐で初めてアクセスする場合にリストを与えてから、それ以降にappendする必要があった。

collections.defaultdictは、valueの型を与えた関数型で初期化(統一？)し、存在しないキーにアクセスしても空のそれに対して操作可能な辞書のようなdefaultdictを作成することができる。

たとえば出現場所を格納したリストをvalueにした辞書を作りたいのであれば、itertools.defaultdict(list)として、キーの存在の有無にかかわらず.append()すればよい



# ☆ 224C Triangle 

sample2の出力が1123のまま改善せず諦め

問題把握 03:23  発想 00:00  base 04:30 　計 30:50


備考

➀ 小数と誤差

三角形の成立条件を傾きで判定する場合、当然割り算を行うがpythonでは小数点15桁付近で丸目込みが発生するので割り算を行うと情報が抜け落ちる可能性がある(0726 215B 参照) 

この問題でもsample2で誤差による影響で正しい答えが出力できない。したがって割り算を行わない処理が求められる。この問題では傾きの比較演算の際、分母を払うことで掛け算のみで判定を行うことが可能になる。またそれだけではなく割り算がなくなったために煩わしい条件処理の必用すらなくなりいいことずくしである。


また、問題に誤差について明記されているものは小数を扱うことで生じる誤差を許容するというサインなのかもしれない。逆にそれ以外の場合は積極的に小数演算を回避する必用がありそうである。





# 221C Select Mul

解答遷移 AC

問題把握 & 発想 13:34   提出まで 25:20  計 38:55


備考

➀　思考

順列は作ったことないから引き出しがない。仕方ないから桁数の階乗回ループして数字を作成するか　→ 階乗演算のやり方わからなくて調べたら普通にitertools.permutations(irter,取り出す個数)でイテラブルの要素n個からなる順列をcombinationsやproductの様に生成できることがわかったので、これを採用

N=10^9の場合 10! * 9(分離する境界)　で速度がギリギリなのでスライス分離はpypyでもTLEするなと感じたため工夫をかんがえた。すると商と余りの演算で分離可能だと気づいたため、あとはすでに計算した処理を行ないようにseenリストなどで管理しようと思ったが、よく考えたら別に同じ計算をしても問題はないのでやめた。また0始まりの分離をふせぐ処理が必要だと感じたため、分離した2数の長さと余りが非0の条件分離を施して解答できた。

ただよくよく考えると積の最大値さえわかればよい今回、0始まりの分離の積どうせ最大値ではないので含めても問題がなかった。

➁ itertools.permutations(iter,n)

与えたイテラブルの要素n個からなる順列を生成

③ math.factorial(n)

n!を出力


④ 別解

積に影響するのはNの選び方でなく、分離の仕方である。また分離した数同士の積は当然分離した数が最大の状態で最大値をとる。このことからNの各桁の数を左右どちらに分離するかbit探索し、その後分離後に降順二並び替えて積を求める処理を行えばよい。



# 229C Cheese

解答遷移 AC

問題把握 01:53  発想 03:13  提出まで 25:30  計 30:38


備考

➀ 思考

・作成前

dpだ。でもW<=3* 10^8ってリストサイズにしてはでかすぎない？　→ でもまあやるしかないか

・作成中

いやWとnでループするの無理だわ。じゃあdpじゃないわ。→ てことは貪欲法？　→ Aが格納効率をそのまま表していることに20分ぐらいかけて気づく。


・AC後

u2dayoを使うチーズの数を全探索しなくても min(W,AB[n][1])で一発なことに気づいた。深く反省



➁ dp

dpを久しく扱っていないせいで制約から不可能なことにしばらく気付けなかった。またシンプルにdpのコーディングが困難になっている。要復習





# 210C Colorful Candies

解答遷移 WA AC

問題把握 01:34  発想 03:43  base 15:37  デバック&提出 03:35  計 24:29 + 05:00


備考

➀ 思考 

前から順に探索していき、連続個数をさらにsortやループで探索すると制約にひっかかるのでcollections.Counterで色の数を管理しよう。→ 探索が進むごとに新しいcandieの色を+1して、連続の範囲から外れる色を-1すれば良いな

しかし、途中でvalueが0になってもそのままキーが保存されることに気づき、collections.Counterではない別のなにかで管理する方針に切り換えようとする　→ しかし代替案がうかばなかったので0になったキーを削除することに。dictにおいてpop(key)によってO(1)でキーを削除出来るので同様にcollectionsでも高速で処理可能だと判断し実装

WAは単純に削除するキーを追加するキーの法に誤って設定していたため発生した。



➁ pop以外での管理

-1して値が0になったら色が減った、+1して1になったら色が増えたと判定して変数tmpを増減させて ansと比較する方法でも解ける



# 0821 

# 204C Tour  diff 629 済

解答遷移 AC

問題把握 02:10 発想 02:42  base 06:03  デバック&提出 10:22


備考

➀　思考

・base作成まで

dfsで探索できそうだな。都市を探索してその都市からいける都市をさらに探索する処理はループ回数がmax 10^6 なので制約も大丈夫。

・デバック

sample1に救われたが、都市が互いに行き来できると永久ループするのでseenで行った都市とstartした都市を管理する必要がある。searchはsetで管理すればO(1)なのでOK


➁ 再起関数の変数

global変数を更新するには関数内で変数のグローバル化を宣言する必要がある。またリストに保存して、処理が終わった後にその情報を引っ張る方法もある。

* 233C のように再起関数でのみあつかいたい変数は引数に入れておくと管理が簡単




# 0822

# ☆ 220C Long Sequence   diff 119

解答遷移　WA  AC

問題把握 発想 08:24    base  08:12  デバック&提出 15:35  計 32:31+05:00


備考

➀ 思考

累積和がつかえそうだけど、全て保存するのは絶対無理。一週目の値によって、何周することでXを超えられるか X- AA[n]//accA で求め、一週の値を全探索して最小の周回数を持つ最小のindexを出す。


➁ WAの理由

X以上だと思ってしまい、(X-AA[n] +accA -1)//accA によって切り捨て演算を行っていた。Xとちょうど同じ値でも+1する必要があった。

条件分岐のこの読み取りミスよくやるので注意


③ 別解

わざわざ探索しなくても、あらかじめ何週必要なのかはx=X//sum(A)で求められる。その後x+1週目を前から順に探索してx * NにA[n]を加えた値がXを超えればN * x + n +1　で初めてXを超える場所がわかる。(なにもない場所を0週目と考えることで何週目か考えやすい)

また、x週目の最後の値がちょうどXだった場合でもx+1週目を探索できる。





* 復習

int(X)はXを0に近づくように丸める。//はガウス



#  ☆ 231C Counting2  

numpyではどうしても通らず諦め

備考

➀ sortして前から順にxqと比較する処理はTLEするので工夫が必要だと考えた。そこでnumpyを用いて全要素に対して-xqする処理を行い0以上の要素の個数を求めようとした。

しかしTLE 。そもそもnumpyの配列は要素数の計算量を消費するのかもしれない。それなら今回の処理では2重ループと変わらないのでTLEするのも無理ない

![image](https://user-images.githubusercontent.com/109026838/185960660-fc3c6a64-05b8-4ae3-b027-70c0187119a2.png)


Akari_のコードも見てみたが、numpyを使ってはいるものの2部探索していたのでやはりループ内で10^5の要素を持つ配列を使うのは厳しいか


➁ 2分探索 numpy.searchsorted(A,V)

ソート済み一次元配列Ａに対して、Vがどの位置に挿入できるかindex番号を返してくれる。デフォルトでは左側に挿入する前提の答えが得られる。またVは配列を与えることができ、その場合Aに対してVのすべての要素をどこに挿入できるかの配列を得られる。

* 標準ライブラリ bisect.bisect_leftではVにリストを与えられなさそう

③ 別解

身長とxをまとめてソートして挿入を実現する。そこからxがどれかを明確化するため追加情報を与えておく。xのほうに与える情報としては出力の際にxのもともとの場所の情報が必要不可欠なのでそれが適切。Aのほうに与える情報としてはxの明確化を邪魔せず適切にsortできるものなら何でもよいだろう。例えば負の値を与えてしまうと、xとAの要素が同じ値だった場合に、xが先に出現し、xより大きな要素の数を求めてしまうためこれは不適切である。



# 2分探索　勉強➀

# アルゴ式 2分探索

# Q2-3 最小の添え字

解答遷移 AC

問題把握 発想 01:24  base 02:48  デバック& 提出 03:45  計 07:58

備考

➀ np.searchsortedで二分探索するだけ

side="left"での出力は、挿入されるindex番号を表すが、様々な解釈ができる。例えばこの問題のように挿入する値を超えることのない最大の値を持つ要素のindex番号とも解釈できるし、また挿入する値未満の数が要素としていくつ存在するのかを表していると解釈することもできる。逆に"right"では、挿入する値を上回る値を持つ最小のindex番号とも解釈できるし、挿入する値以下の要素がいくつ存在するのかを表していると解釈することも可能。




# Q 2-4 小さい数の個数

解答遷移 AC

計 15:24

備考

➀ Q2-3参照




# ☆ Q2-5 和が K 以上のペア

解答遷移 諦めて軽く解説診つつ 2-3に戻る  TLE  AC

問題把握 発送 02:21   base 03:08  デバック&提出 04:35  計 10:05

備考

➀ 値の固定化で変化する問題の解釈

iとjを探索してK以上か調べることはできない。しかしjのみをある定数に固定してAi>=K-Ajを考えると、Aの中でK-Ajを挿入する場所を探す二分探索と解釈できる。つまりjを全探索して二分探索を行うことを繰り返す処理を行えばよい。計算量O(N * logN)であるから十分高速である。





# Q 2-6 重さは何番目?

解答遷移 AC

計 07:59  (例のコピーの形式がatdcoderと異なる点にと間取り時間を浪費した)


備考

➀ np.searchsortedで二分探索するだけ






# 0823

# 216C Many Balls  diff 145   済

解答遷移 AC

問題把握 03:02  base 01:58  デバック&提出 2:48  計 07:49


備考

➀　思考

abのbit探索は制約的に無理。→ x * 2 + 1 の操作がABを一回ずつ行う操作であることに気づく。つまり2 ^ 60 > 10 ^18であれば120回の操作でNに到達できることがわかる。 2 ^60 > (10^3) ^ 6 > 10^18なのでOK。N%2=1なら//2を、そうでなければ-1する処理をNが0になるまで繰り返し、操作の種類を保存。逆順で返せば完了

➁ 別解

2倍を2進数表示の桁上がりと解釈すれば、Nの2進数表記と比較しながらABの操作を表す2進数を作成することでこの問題を解くことができる。例えばN=5=101(2)だが、初めに0を定義し(操作B)、N[0]=1なので+1(操作A)、もう一度0を加えてN[1]=0なのでAを行わなず、0を再度加えて+1すればBABBAで完了できることがわかる。N(2)の桁数分探索するわけだが、 10^18 < 2^60 よりNは2進数で表すと60桁未満なので120回の制約が守られる。



# 213C Reoreder Cards  diff 481

解答遷移  AC

問題把握 03:49  発想　03:10  base 05:49  15:19  計 28:08

備考

➀　思考

・作成前

カードで探索しそうだな。 → とりあえずsetで残る行と列のindexは簡単に取得できる。その中の最小値を全要素から引いて+1(index調整)する処理でいいな。

デバック

・普通に合わないので再試行。→ 最小値で調節できるのは一番最小のものだけだ。全要素に対してsortした順番で値を更新する必要がある。複数の要素に対して同じsort列のどこに挿入できるか調べるためには二分探索すればいいな　→ AC完了


➁　座標圧縮

この問題は座標圧縮と呼ばれるアルゴリズムの典型的な問題らしい。sortした値をキーに、index番号をvalueに与えた辞書を作ることで解くそう。やってることは二分探索と同じ







# 0824 

# 205C Pow  diff 63

解答遷移  TLE AC

問題把握 発想　00:17  base 01:14  デバック&提出 04:55  計 06:27 + 05:00

備考

➀ TLE

A,B,Cの制約を確認せずに、問題の容易さに飛びついて素直に A^C とB^Cを比較する処理を実装しTLEしてしまった。

その後、偶関数か奇関数かで場合分けしてACできた



# 208C Fair Candy Distribution  diff 142

解答遷移 AC

問題把握 02:21  base 04:52  デバック&提出 02:21  計 09:34


備考

なし




# ☆ 201C Secret Number　　diff 439　　済

諦め

備考

➀ 諦めに至る経緯

oの数で条件分岐。たかだが5通りだと考えてこの方針を採用したが?の種類で分岐がハチャメチャに増えて管理できなくなって諦めた

➁ 場合分け解

パスワードに使用する数字の個数がわかれば、その数字を使って作ることができる4桁の数字が何個あるか出力できることに注目。?の個数で全探索して使用する数字を1～4の範囲で動かす。

* 自分の案との違い

自分の案はoの数で場合分けしてもそれぞれの出力方法に共通点がないので、すべての場合の処理を網羅しなければならない難しさ、別々に作成しなければならない煩雑さがあった。実際網羅しきれずに諦めている。

* 反省

oの数の場合分けがたかだが5通りなことに完全に甘えたことが敗因。楽するために共通点を見つけようと考えていれば、使用する個数が大切なことに気づけたかもしれない。



③ 別解

探索対象をパスワードにする。パスワードは0～9999のたかだか10000個なので余裕で探索可能。4桁まで0埋めして、出てくる数字を集合numで管理。o,x,?の数字もそえれぞれ use , unuse , unknowの集合で管理し、useにnumに含まれる数字以外の数字がなく、かつ use とnum に共通の要素がなければ、つまりuseとnumの差集合が空　かつ use と unuse の和集合が空なら そのパスワードは条件を満たすと判定する処理を行なえばよい。

なお、unmとunuseに共通要素がない状態で、numに含まれるuse以外の要素は必ずunknownの要素なので、unknownを用いた処理をおこなう必要はない。



# 199C IPFL  diff 436   * 類題 258C,158D　　済

TLEしない方針を思いつかず諦め

備考

➀ 模範解答

前半と後半をO(1)で入れ替えるためにそれらを分離してリストSに格納する。これによってS[0],S[1]で簡単かつO(1)で前半公判を呼び出せる。

その後、t=1の時には、a-1,b-1がN未満かどうかで条件分岐しN未満ならS[0]を操作するために0とa-1,b-1を保存し、N以上なら1と(a-1)%Nを保存する。これらをind,tmpとして保存していたのなら、S[ind][tmp]で入れ替える場所にアクセスできる。t=2ならS[0]とS[1]を入れかえるだけ。

最後にSを一次元に戻して"".join(S)によって文字列を結合すればOK 

* 平坦化はitertoolsを使うか、単に、S=S[0]+S[1]とすればよい



➁ 別解

前半後半の順序の状態は入れ割っている状態かそうでないかの二パターンであることに注目してこれをflagで管理し、疑似的な入替を実現する。t=1かつflag=Trueなら入れ替わっている状態なので、a1を(a-1+N)%(2* N) として入れ替える場所を操作する。t=2ならflagを変化させて前半後半の状態を変化させる。




# ☆ 198C Compass Walking  diff 413

方針が分からず諦め

備考

➀ 始点sと終点eをそれぞれ中心とした半径Rの円を描くと、dist(s,e)<2* Rのときの交点を経由することで2歩で始点から終点に移動できる。(dist(x,y)でx,yの距離を表すとする)

これに気が付けばZ=dist((0,0),(X,Y))//R が整数であればZを解とし、それ以外であればZ未満の最小の整数歩 -1歩進み 2歩進んで、すなわち[Z]+1で移動できることがわかる。したがって、Zを切り上げたものが答えになる(コーナーケースは除く)


➁　切り上げ演算

aをbで割り小数点以下を切り上げる演算は (a+b-1)//bで行っていたがこれはa,bともに整数の場合のみ成立する。例えばa=12.1,b=3のとき5は出力されない。小数が絡んでしまう場合はmath.ceil()を用いて切り上げよう


③ 小数演算による誤差

例えばx=10^16 y=10^16になると dist(x,y)とdist(x-1,y)は同じ値になってしまうので誤差が生じる。今回設定されたx,yの範囲では値が変化すれば距離が必ず変化するで小数演算を行ってもACできる。割算演算ではもう少し値が小さくても誤差が発生するが、sqrtは結構耐えられるほうっぽい。



# 186D Sum of difference diff 436 

解答遷移 AC

問題把握 01:21  発想 03:23  base 02:15  デバック&提出 01:09  計 08:10

備考

なし




# 185D Stamp  diff 490

解答遷移 AC

問題把握 発想 06:23  base & デバック 18:07  計 24:30

備考

➀　速度ボトルネック

連続する白マスの情報をリストに格納したいけど、リストの長さとして大きすぎないかの確認に一番手間どった。結果的には長さはほぼMだと把握しそのまま実装





# 183C Travel  diff 335   済

解答遷移 AC

計 1:01:36

備考

➀ 思考

・作成前

根を1にした木を作成してdfsすればいけるな。7!なので十分高速。seenで行った都市を管理して、seum(seen)=Nになったら1に戻る処理を行い、時間を累積して最後にKと比較しよう

・デバック

その経路で生じる時間と、seenを初期化しなくてはいけないと気づく　→ 時間のほうは引数にすることで管理できるが、seenの管理ができない。どうしようか

・新案

経路がわかればその順に探索すればよいのでpermurationsで経路を出力して処理を行うことにしてACできた

・解答後

帰りがけにsennから除去すれば適切に都市を管理できることに気付き、dfs方針でもACできた






# 202C Made Up  diff 204

解答遷移 TLE TLE AC

問題把握 01:19  発想 から終了まで25:19  計 26:39 +10:00


備考　

➀ 思考

Aの要素で全探索してA[i]を与えたときに、A[i]=B[C[j]]を満たすjの個数が返るような処理がしたい。　つまりBのvalueをキーに、そのvalueにアクセスできるCのindex番号の個数をvalueにした辞書を作ることを目指す。B index +1 = C value * ☆ であることに注目してCのvalueの数をCounter:CCで管理し、BB[B value] = CC[i+1]とすれば、このBBが目的の辞書になる。


➁ 速度ボトルネック

必用な知識は全て持っていたのに、どれをキー、valueにしてどうやってつなげるか整理するのに時間がとてもかかった。☆のような重要な関係式を記述すればわかりやすくなるかもしれない。



#  194C Squared Error  diff 386C

解答遷移 AC

計 28:46


備考

➀ アルゴリズム & ボトルネック

186Dと似てるから累積和使いそうだなと頭の片隅にあったので、(a-b)^2の展開式の-2* a * bをaでまとめたときに-2* a * (accA[A(a).index()]-a)とすることで求められることに気づいた。しかしこれに至るまでの他の部分の考察がうまくいかず実装前に時間がかかってしまった





#  171C One Quadrillion and One Dalmatians  diff 560　　済 230121

解答遷移 AC

問題把握  00:36   提出まで 26:54   計 27:30


備考

➀ 思考

N>=26^x + 26^(x-1) +...+ 26 を満たす最大の整数xが知りたい。０から始まる右辺の累積和を作成し、二分探索でx+1が求められることに注目。26をx 回かけてできる数のうちNが前から何番目かが重要なのでそれを示すXを作成し、Xを26でx+1回割る処理を行う。前のアルファベットから求めたい場合は26^xで割り、次は26^(x-1)と降順に処理することになる。後ろからなら余りで分類


➁　数学的な考察　26進数

感覚でAC解答を作成したが、整数をn進法で考えてN=a* n^x + b* n^(x-1) + .... y * n^1 + z * n^0 と展開できるとき、N=abcd...z(n)になることを理解し、この問題も26進数の問題であると解釈できるかがポイントになる

このように考えると自分の方針で26で割った商を名前に追加し、次の名前を求めるためにその余りを利用する処理が正しいかったことも納得できる。

そもそも何桁か求めずともこの処理のみで名前がabcd..になりそうだがそれは違う。例えば、26=10(26)なので
baになりそうだが、この問題ではaaにならなければいけないからだ。原因は桁が上がるときに0を使えないこと。詳しくは下記

https://drken1215.hatenablog.com/entry/2020/06/21/225500

自分の処理では桁が上がらないので解説を見ても何を言っているのかわからなかったが、この問題のみそはここにあった模様。なお、N//26の後に-1をする処理を追加することで解決可能 

























































