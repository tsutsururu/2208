# 0802

# 記録さぼり + 保存ミスで消えた0729以降の記録を復讐しながら簡易的に再掲載

# ARC031B 埋め立て　2回目

解答遷移  AC

baseまで 17:42  デバック 01:20

備考

➀ 「島がひうとつながりである」か否かの判定を、探索した陸を消して最後に陸が残っているか否かで判定することが可能。

解答例 : https://ebisuke33.hatenablog.com/entry/antbook-arc031b


# 233A 10 yen Stamp

備考

➀ XをYで割った解の小数切り上げ

(X+Y-1)//Y

イメージ的にはX//Yをbaseに、XがYで割り切れる時以外は、+Yの部分が効いて切り上げられる。

割り切れる場合は-1の部分が効いて、切り上げが起こらないようになる。

➁ Xが既にYを上回っている場合

この場合に((X+Y)+10-1)//10 をすると負値になるので条件処理するか、max(0,)とする



# アルゴ式 グラフアルゴリズム

# 1-2 フォロー

備考 

なし



# 1-3 人気者の友達 2回目

解答遷移 AC

baseまで 08:08  デバック&提出 04:52  計 13:00

備考

➀ * 復習 mapはイテレータ

A=[1,2]のとき

a,b=A , a,b=map(int,A)  と要素にアクセスすれば違いはないがa=Aとすればリストが返ることと違ってイテレータは返らない

➁ 復習時と初見時の方針の違い　（情報の分割)

復習時

ABを入力から得た友達リストとしてA[n]に[nの友達の数(len(AB[n]) , -n , AB[n]]を格納しソートすることで友達の数が多い順でかつindex番号が小さい順に並べ替えることができる。そして最後にsorted(A)[0][-1]をソートすればよい。

初見時

入力からで友達リストを作成すると同時に、友達の多さリストを作成。多さリストの最大値のindex番号こそ、友達が最も多くindex番号が小さいもののindex番号になるので友達リストからそのものの友達を求めればよい。


確実に初見時のほうがスマート。ループ処理1回で解決している。全ての情報をはらんだリストを再構築する復習時のほうが情報をコンパクトにまとめられる点は優れているが、友達の多さは多い順、index番号は若い順で異なるためindex番号を-1倍処理する必要があることや、そもそもどんな情報を格納すべきか難しい部分があるため自分では実装に時間がかかってしまう。



# 1-4 友達の友達 2回目

解答遷移 AC

備考

➀ リストの要素検索

a (not) in A としてAの要素にaがあるかの処理は　O(n) である。よって制約次第で使えなくなる可能性が高い。setであればO(1)らしいのでこちらを使用するようにする。

![image](https://user-images.githubusercontent.com/109026838/182563153-57676d80-383b-4188-a3d3-7d2f9bf4e5ef.png)

*  2-2後 追記

リストをセットに変換して要素検索するのと、セットを直接検索するのとでは計算時間が異なる(0801_0806 tttt.py参照)

そのため検索したい場合にはあらかじめ空のset()を作っておき、こちらにも値を格納する処理がTLEしないためにより良い。




# 2-1 箱の中の箱

解答遷移 AC

問題把握 01:43  発想 01:42  base & デバック 05:05  計 08:31


備考

➀ 根からの探索

特定の頂点(箱)Xの深さを調べるなら、根からでたらめにたどっていくよりも直接その頂点から根に向かった方が効率的

➁ dp的解放

「ある頂点(箱)における根からの深さは、その親の頂点の深さ+1 」 である性質を利用すればすべての頂点の深さを求めることができる。


# 2-2 行きがけ順

解答遷移 RE(TLE)  AC 

問題把握 00:32 　発想 00:01  base 17:13  計 17:46

備考

なし


# 2-3 
































